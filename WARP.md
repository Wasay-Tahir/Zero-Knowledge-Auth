# WARP.md

This file provides guidance to WARP (warp.dev) when working with code in this repository.

Project overview
- Monorepo with four parts:
  - backend/: Node.js/Express TypeScript server for registration, nonce issuance, proof verification (snarkjs), and JWT issuance
  - circuits/: Circom v2 circuits and instructions to produce proving/verification artifacts
  - mobile/: Flutter client app (to be bootstrapped) handling local crypto and optional WASM proving
  - contracts/: Optional Hardhat project to deploy an on-chain verifier generated by snarkjs

Commands you’ll use

Backend (Node.js/TypeScript)
- Install deps
```bash path=null start=null
cd backend && npm install
```
- Run in dev (ts-node + nodemon)
```bash path=null start=null
npm run dev
```
- Build and run compiled server
```bash path=null start=null
npm run build
npm start
```
- Env used by server (example for local)
```bash path=null start=null
export PORT=3000
export JWT_SECRET=dev-secret-change-me
# Path to snarkjs verification key JSON produced in circuits/
export ZK_VKEY_PATH=circuits/verification_key.json
# Paths for server-assisted proving (optional, dev-friendly)
export ZK_WASM_PATH=circuits/build/PasswordAuth_js/PasswordAuth.wasm
export ZK_ZKEY_PATH=circuits/keys/PasswordAuth_final.zkey
```
- Minimal smoke tests (manual) for routes
```bash path=null start=null
# Register a user (commitment is a decimal string)
curl -X POST http://localhost:$PORT/auth/register \
  -H 'Content-Type: application/json' \
  -d '{"username":"alice","commitment":"123456","salt":"789"}'

# Get a nonce for that user
curl "http://localhost:$PORT/auth/nonce?username=alice"

# Server-assisted login (requires WASM+ZKey paths set and compiled artifacts)
# password/salt are decimal-encoded as expected by the circuit
curl -X POST http://localhost:$PORT/auth/login \
  -H 'Content-Type: application/json' \
  -d '{"username":"alice","password":"42"}'

# Client-provided proof verification (if you generate proof on client)
curl -X POST http://localhost:$PORT/auth/verify \
  -H 'Content-Type: application/json' \
  -d '{"username":"alice","proof":{...},"publicSignals":["..."]}'
```
- Lint/tests: no linter or tests are configured yet (package.json has a placeholder lint script).

Circuits (Circom + snarkjs)
- Prereqs: circom v2, snarkjs
- Compile the circuit and generate WASM
```bash path=null start=null
cd circuits
circom PasswordAuth.circom --r1cs --wasm -o build
```
- Example Groth16 setup and key export (local/dev)
```bash path=null start=null
# Powers of tau
snarkjs powersoftau new bn128 12 pot12_0000.ptau -v
snarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau --name="first" -v
# Circuit-specific
mkdir -p keys
snarkjs groth16 setup build/PasswordAuth.r1cs pot12_0001.ptau keys/PasswordAuth_0000.zkey
snarkjs zkey contribute keys/PasswordAuth_0000.zkey keys/PasswordAuth_final.zkey --name="phase2" -v
# Export verification key for the backend
snarkjs zkey export verificationkey keys/PasswordAuth_final.zkey verification_key.json
```
- Point the backend to the exported key via ZK_VKEY_PATH and to WASM/ZKey via ZK_WASM_PATH/ZK_ZKEY_PATH for server-assisted proving.

Mobile (Flutter)
- Bootstrap the app (not yet committed)
```bash path=null start=null
cd mobile
flutter create zk_login_app
```
- Move or develop the generated app within mobile/.

Contracts (optional Hardhat)
- Initialize and generate verifier
```bash path=null start=null
cd contracts
npm init -y
npm i -D hardhat @nomicfoundation/hardhat-toolbox
npx hardhat  # create empty project scaffold
# Generate Verifier.sol from the zkey produced in circuits/
snarkjs zkey export verifier \
  ../circuits/keys/PasswordAuth_final.zkey \
  contracts/Verifier.sol
```

Architecture and flow
- Circuit: circuits/PasswordAuth.circom
  - Proves Poseidon(salt, password) equals stored commitment and outputs Poseidon(pwHash, nonce) as a challenge hash.
- Backend: backend/src/index.ts
  - In-memory stores: users (username → {commitment,salt?}) and nonces (username → nonce).
  - Endpoints:
    - POST /auth/register: validates with zod and stores username+commitment(+salt).
    - GET /auth/nonce: issues a single-use nonce, returns { nonce, salt? }.
    - POST /auth/verify: client-submitted proof path; on success deletes nonce and returns a JWT.
    - POST /auth/login: server-assisted proving path; uses backend/src/zk/prove.ts to run groth16.fullProve, then verifies and issues JWT.
  - ZK verification: backend/src/zk/verify.ts lazily imports snarkjs and loads the verification key from ZK_VKEY_PATH, then runs groth16.verify(publicSignals, proof). Server-assisted proving in backend/src/zk/prove.ts uses ZK_WASM_PATH and ZK_ZKEY_PATH.
- Client flow (as designed in README):
  - Register: client computes commitment = Poseidon(salt, password) locally and sends to backend.
  - Login: client requests nonce, builds witness {password, salt, nonce}, generates Groth16 proof (on-device via WASM or server-assisted), submits to backend for JWT.

Notes
- There is no test runner configured; if you add one later (e.g., Jest for backend), prefer documenting single-test invocations here.
- Keep large proving artifacts (.zkey, .ptau) out of VCS; the backend consumes only the JSON verification key.
